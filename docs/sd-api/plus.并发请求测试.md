# 并发请求测试
考虑到实际业务中会对 webui 做并发形式的调用，这里对并发请求场景做测试，作为后续开发的参考

## 测试的场景与表现
|场景|相关接口|表现|
|---|---|---|
|同时并发多个文生图请求|/sdapi/v1/txt2img|webui并不会并发执行这些请求,而是会按照请求顺序依次执行(内置队列)|
|请求后客户端取消请求操作|/sdapi/v1/txt2img|webui并不会停止执行，即其内置队列不会有对req.close的处理|
|请求后调用中断接口中断操作|/sdapi/v1/interrupt<br>/sdapi/v1/txt2img|1. 每次只会中断一个任务<br>2. 中断后会直接对之前的请求做响应，但是返回的图片是当前处理到中途的图片|

## 相关策略
由上述的测试场景可知:  
1. sd-webui 的内置任务管理机制比较薄弱  
1. 对于单个 sd-webui 实例其主要服务于单任务的执行  

对此非独有 serverless 的底座需要封装一个服务于调度 sd-webui 的周边调度服务，其策略如下:  
1. 使用锁机制确保不会再 sd-webui 侧积累多个任务，保持其单任务运行状态  
1. 以积压的任务数作为动态扩容的指标(适配autodl)  
1. 监听请求中断，主动释放对 sd-webui 实例的资源占用(适配autodl)  

对于独有 serverless 的底座，其策略如下:  
1. 不需要锁机制  
1. 对于 runpod 请求中断处理需要实际测试确认
